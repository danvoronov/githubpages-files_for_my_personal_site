<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>ШІ в розробці ПЗ: поточний стан та перспективи</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">ШІ в розробці ПЗ: поточний стан та перспективи</h1>
</header>
<section data-field="subtitle" class="p-summary">
Перші кроки в розвитку доповнення коду були зроблені у 1957 році, зокрема, першими були спелчекери, що перевіряли правильність написання…
</section>
<section data-field="body" class="e-content">
<section name="d4e7" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c663" id="c663" class="graf graf--h3 graf--leading graf--title">ШІ в розробці ПЗ: поточний стан та перспективи</h3><p name="434a" id="434a" class="graf graf--p graf-after--h3">Перші кроки в розвитку доповнення коду були зроблені у <strong class="markup--strong markup--p-strong">1957 </strong>році, зокрема, першими були <strong class="markup--strong markup--p-strong">спелчекери</strong>, що перевіряли правильність написання основних інструкцій (<a href="https://en.wikipedia.org/wiki/Code_completion" data-href="https://en.wikipedia.org/wiki/Code_completion" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">вікіпедія Code completion</a>).</p><p name="fecf" id="fecf" class="graf graf--p graf-after--p">У <strong class="markup--strong markup--p-strong">1996 </strong>році у MS Visual Studio була додана функція автоматичного доповнення коду. Хоча <a href="https://stackoverflow.com/questions/2940478/which-ide-code-editor-was-the-first-to-introduce-a-code-completion-feature" data-href="https://stackoverflow.com/questions/2940478/which-ide-code-editor-was-the-first-to-introduce-a-code-completion-feature" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">на Stack Overflow вказують</a>, що деякі функції покращення коду також були присутні в Turbo Pascal через Alice, все ж можна вважати початком саме введення функції <strong class="markup--strong markup--p-strong">IntelliSense</strong>.</p><blockquote name="03ec" id="03ec" class="graf graf--blockquote graf-after--p">IntelliSense прискорює процес розробки програмного забезпечення, зменшуючи кількість введення з клавіатури та потребу в запам’ятовуванні назв. Вона також дозволяє користувачам рідше звертатися до зовнішньої документації, оскільки інтерактивна документація для багатьох символів (наприклад, змінних та функцій) у поточному контексті відображається динамічно у вигляді підказок.</blockquote><figure name="95f3" id="95f3" class="graf graf--figure graf-after--blockquote graf--trailing"><img class="graf-image" data-image-id="0*gkt8n8nKNvaES4EX.png" data-width="252" data-height="204" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*gkt8n8nKNvaES4EX.png"></figure></div></div></section><section name="c4ce" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8b8d" id="8b8d" class="graf graf--h3 graf--leading">(1) Автодоповнення блоків коду</h3><p name="3e78" id="3e78" class="graf graf--p graf-after--h3">Якщо говорити про ШІ, то 29 червня 2021 року GitHub оголосив про технічний попередній перегляд<strong class="markup--strong markup--p-strong"> GitHub Copilot</strong> у середовищі розробки Visual Studio Code, далі JetBrains та Neovim. Повністю як платний сервіс для індивідуальних розробників відкрили <strong class="markup--strong markup--p-strong">21 червня 2022 року</strong>.</p><p name="19d2" id="19d2" class="graf graf--p graf-after--p">Була використана базова велика мовна модель (LLM) <a href="https://openai.com/blog/openai-codex" data-href="https://openai.com/blog/openai-codex" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Openai Codex</a>, яка може генерувати кожен наступний токен, тобто за початком коду у файлі (це буде контекст) вона генерує <strong class="markup--strong markup--p-strong">продовження</strong>. На відміну від попередніх систем, тепер видаються цілі <strong class="markup--strong markup--p-strong">блоки </strong>коду.</p><blockquote name="4d9c" id="4d9c" class="graf graf--blockquote graf-after--p">Можна перемикатися між декількома варіантами. Для покращення точності можна написати коментарі, в яких буде вказано, що буде враховано при подальшій генерації.</blockquote><figure name="8e33" id="8e33" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="0*H4U0Ust1cF4HtMnS" data-width="1024" data-height="452" src="https://cdn-images-1.medium.com/max/800/0*H4U0Ust1cF4HtMnS"></figure><p name="8a83" id="8a83" class="graf graf--p graf-after--figure">Більш розширена версія (<a href="https://cursor.sh/features#cpp" data-href="https://cursor.sh/features#cpp" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">у Cursor має назву Copilot++</a>) може генерувати доповнення як усередині рядка, так і у мультирядковому форматі.</p><blockquote name="3d51" id="3d51" class="graf graf--blockquote graf-after--p">Зазвичай використовується модель відносно невеликого розміру (близько 2-7 млрд параметрів) натренована на якісному коді, тому такий сервіс легко зробити. Також їх можна запускати локально.</blockquote><p name="43fb" id="43fb" class="graf graf--p graf-after--blockquote">Далі прийшли конкуренти:</p><ul class="postList"><li name="0c06" id="0c06" class="graf graf--li graf-after--p">комерційні <strong class="markup--strong markup--li-strong">Tabnine, Codeium</strong> та інші (зазвичай не пишуть що за модель використовують)</li><li name="d6ac" id="d6ac" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Tabby </strong>як опен-соурс та самостійно хостінговий проект (<a href="https://tabby.tabbyml.com/docs/models/" data-href="https://tabby.tabbyml.com/docs/models/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">каталог моделей</a>)</li><li name="8e0f" id="8e0f" class="graf graf--li graf-after--li graf--trailing">плагіни VSCode які через локальний сервер <strong class="markup--strong markup--li-strong">ollama </strong>доповнюють код</li></ul></div></div></section><section name="df18" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0e0d" id="0e0d" class="graf graf--h3 graf--leading">(2) Чат-інтерфейс <strong class="markup--strong markup--h3-strong">парного програмування</strong></h3><p name="836d" id="836d" class="graf graf--p graf-after--h3">Після швидкого успіху <strong class="markup--strong markup--p-strong">ChatGPT </strong>(старт 30 листопада 2022 року) стало зрозуміло, що можна описати текстом те, що вам потрібно, і отримати відповідь у вигляді <em class="markup--em markup--p-em">згенерованого </em>коду. На початку 2023 року почали з’являтися плагіни для IDE, які вставляли бічний чат з моделлю GPT-3.5-turbo через ключ API OpenAI.</p><p name="7048" id="7048" class="graf graf--p graf-after--p">Тут ми виходимо за межі генерації блоків і відразу можемо просити створювати цілі файли з кодом (такі як модулі).</p><p name="1847" id="1847" class="graf graf--p graf-after--p">GitHub Copilot Chat як частина <strong class="markup--strong markup--p-strong">GitHub Copilot X</strong> був анонсований 22 березня 2023 року. У пості від 29 грудня 2023 року було повідомлено, що чат тепер тепер доступний для всіх та працює на GPT-4.</p><blockquote name="ddf2" id="ddf2" class="graf graf--blockquote graf-after--p">Можна задавати та отримувати відповіді на питання, пов’язані з програмуванням. Також чат-інтерфейс надає доступ до деяких команд автоматизованої розрозбки — генерація юніт-тестів на основі коду, пояснення коду та пропозиція покращень, пропозиція виправлень помилок у коді на основі опису помилки (з консолі) та оточуючого коду.</blockquote><p name="1043" id="1043" class="graf graf--p graf-after--blockquote">Сам підхід є розвитком ідеї <strong class="markup--strong markup--p-strong">парного програмування</strong>: я спілкуюсь з чатом звичайним текстом, а він створює або змінює код. Теж можу дописати код, потім ще питати чат, ітд.</p><p name="40f8" id="40f8" class="graf graf--p graf-after--p">Більшість функцій це <strong class="markup--strong markup--p-strong">просто текстові інструкції до моделі</strong>, які можна писати у чаті, але для спрощення під них створюють слеш-команди або кнопки. Деякі сервіси надають можливість користувачу створювати свої команди (тобто зберігати промти), а також писати “правила для ШІ”, які будуть додаватися до кожного запиту.</p><p name="8191" id="8191" class="graf graf--p graf-after--p">У GitHub Copilot це: <em class="markup--em markup--p-em">doc </em>(Додає коментарі до вказаного або виділеного коду), <em class="markup--em markup--p-em">explain </em>(Отримує пояснення коду), <em class="markup--em markup--p-em">fix</em> (Пропонує виправлення проблем у виділеному коді), <em class="markup--em markup--p-em">generate </em>(Генерує код для відповіді на вказане питання), <em class="markup--em markup--p-em">help </em>(Отримує довідку з використання Copilot Chat), <em class="markup--em markup--p-em">optimize </em>(Аналізує та поліпшує час виконання виділеного коду), <em class="markup--em markup--p-em">tests </em>(Створює юніт-тести для виділеного коду).</p><figure name="3722" id="3722" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*iOxHxTP0hQqG2SAj.png" data-width="1400" data-height="788" src="https://cdn-images-1.medium.com/max/800/0*iOxHxTP0hQqG2SAj.png"></figure><p name="afd5" id="afd5" class="graf graf--p graf-after--figure graf--trailing">На GitHub Next був <a href="https://githubnext.com/projects/code-brushes/" data-href="https://githubnext.com/projects/code-brushes/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">експеримент із “кистями” Code Brushes</a>.</p></div></div></section><section name="d7e1" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="2615" id="2615" class="graf graf--p graf--leading">Є два напрями логіки вибору моделі: або максимально <strong class="markup--strong markup--p-strong">велика </strong>(зараз це GPT-4 чи Claude-3-Opus) через API доступ, або спеціально <strong class="markup--strong markup--p-strong">налаштована під код</strong> instruct/chat модель (CodeLlama, DeepSeekCoder та інш — в середньому розміру 34 млрд параметрів).</p><p name="b24a" id="b24a" class="graf graf--p graf-after--p">Приклад — плагін для VSCode від <a href="https://www.phind.com/" data-href="https://www.phind.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Phind</a>, який використовує попередньо навчену модель для коду (fine-tuned CodeLlama-34B безкоштовно чи 70B) та візуально під чатом показує, що в поточному запиті буде <strong class="markup--strong markup--p-strong">використано як контекст</strong> — відкриті вкладки, а також фрагменти коду, а також де розташований курсор. Будь-що можна скасувати за допомогою хрестика. Відповідь від чату можна вставити у новий файл за допомогою кнопок, у місце курсора або навіть автоматично застосувати правки.</p><figure name="d932" id="d932" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hXcpQTFzQOuUlrolV5fMzA.png" data-width="406" data-height="224" src="https://cdn-images-1.medium.com/max/800/1*hXcpQTFzQOuUlrolV5fMzA.png"><figcaption class="imageCaption">Phind у VSCode</figcaption></figure><p name="4d8a" id="4d8a" class="graf graf--p graf-after--figure">У <a href="https://cursor.sh/features#apply" data-href="https://cursor.sh/features#apply" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cursor це Apply From Chat</a>, але мене дратує що кнопки у них згори коду, а не знизу.</p><p name="f10e" id="f10e" class="graf graf--p graf-after--p">Зараз багато сервісів інтеграції LLM чату до завдань программуваня:</p><ul class="postList"><li name="f7cb" id="f7cb" class="graf graf--li graf-after--p"><a href="https://sourcegraph.com/cody" data-href="https://sourcegraph.com/cody" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Cody</a>,<strong class="markup--strong markup--li-strong"> </strong><a href="https://docs.double.bot/introduction" data-href="https://docs.double.bot/introduction" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Double</a>, <a href="https://continue.dev/" data-href="https://continue.dev/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Continue</a> (тільки чат без автодоповлення), GitLab Chat, Codeium, Bito, <a href="https://docs.blackbox.chat/blackbox-ai-1/getting-started/vs-code-extension" data-href="https://docs.blackbox.chat/blackbox-ai-1/getting-started/vs-code-extension" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">blackbox AI</a>, CodeGeeX, AskCodi та інш</li><li name="7503" id="7503" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Tabby </strong>як опен-соурс та самостійно хостінговий проект, але для більших моделей краще вже GPU хостінг орендувати</li></ul></div></div></section><section name="996a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="86a8" id="86a8" class="graf graf--p graf--leading">Додатковий варіант — відкриття <strong class="markup--strong markup--p-strong">inline вікна</strong> для написання текстової інструкції прямо в редакторі. <a href="https://cursor.sh/" data-href="https://cursor.sh/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cursor</a> це найкращий приклад, він також може “слухати” додаткові уточнення після генерації відповіді та вносити правки на основі них. Окрім того результат відображається у вигляді DIFF двох кольорів, тому легко перевірити чи все ок.</p><figure name="a700" id="a700" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*NMaVwXPaywCO3Gf0h9-PWg.png" data-width="1045" data-height="772" src="https://cdn-images-1.medium.com/max/800/1*NMaVwXPaywCO3Gf0h9-PWg.png"></figure><p name="7e43" id="7e43" class="graf graf--p graf-after--figure graf--trailing">Мені найбільше подобається цей підхід, оскільки не потрібно постійно відволікатися на чат і втрачати <strong class="markup--strong markup--p-strong">потік </strong>при роботі з кодом. При цьому ми не засмічуваємо наш код постійними коментарями, які були потрібні для генерації в першому методі. Крім того, не потрібно чекати декілька секунд, поки спрацює автодоповнення, а можна відразу відкрити вікно запиту і написати все, що хочеться.</p></div></div></section><section name="3050" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><blockquote name="f688" id="f688" class="graf graf--pullquote graf--leading">Зараз, навесні 2024 року, ми знаходимося саме на хвилі появи таких систем. Все більше стартапів хочуть конкурувати з GitHub Copilot за зручність інтеграції LLM у середу розробки.</blockquote><p name="3eae" id="3eae" class="graf graf--p graf-after--pullquote graf--trailing">Деякі системи дозволяють не тільки запитувати модель про код, але й надавати їй доступ до інтернету та генерувати відповідь на основі результатів пошуку.</p></div></div></section><section name="1608" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fedd" id="fedd" class="graf graf--h3 graf--leading">(3) Контекстне розуміння репозиторіїв</h3><p name="0eaf" id="0eaf" class="graf graf--p graf-after--h3">Наступна проблема, яку намагаються вирішити, полягає в тому, щоб ШІ система автодоповнення коду бачила не лише відкритий файл та вкладки, а знала <strong class="markup--strong markup--p-strong">весь </strong>код у репозиторії, а краще й весь код профілю мого чи компанії.</p><blockquote name="732c" id="732c" class="graf graf--blockquote graf-after--p">І це вже не така проста задача, і поки що існує мало рішень для її вирішення.</blockquote><p name="ccb9" id="ccb9" class="graf graf--p graf-after--blockquote">Рішення, яким йде Google, полягає в <strong class="markup--strong markup--p-strong">збільшенні контекстного вікна </strong>до 1М а потім до 10М токенів, а рішення, яким йдуть всі інші, це <a href="https://en.wikipedia.org/wiki/Prompt_engineering#Retrieval-augmented_generation" data-href="https://en.wikipedia.org/wiki/Prompt_engineering#Retrieval-augmented_generation" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RAG</a>, тобто <strong class="markup--strong markup--p-strong">перетворення коду на ембедінги</strong> у векторній БД та доповнення запиту відповідними частинами.</p><p name="dd79" id="dd79" class="graf graf--p graf-after--p">Наразі презентована 16 лютого 2024 модель Gemini 1.5 Pro від Google з великим <strong class="markup--strong markup--p-strong">контекстним вікном 1M </strong>(а буде й 10M) токенів знаходиться на етапі експерименту і поки що немає робочого продукту на її основі.</p><p name="1405" id="1405" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">RAG</strong>. Такі системи дозволяють шукати та ставити питання щодо вищорівневих концепцій у коді власного проекту. З 29 грудня 2023 року <strong class="markup--strong markup--p-strong">GitHub Copilot</strong> через <code class="markup--code markup--p-code">@workspace</code> у чаті (контекст це всі файли у робочому просторі, за винятком файлів, які .gitignore та індекс пошуку коду GitHub, якщо робочий простір є репозиторієм GitHub та індексується для пошуку). У <a href="https://cursor.sh/features#codebase-wide" data-href="https://cursor.sh/features#codebase-wide" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Cursor </strong>це Codebase Answers</a>.</p><figure name="c7bc" id="c7bc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*zkpDhGx22Tq8MDYH.png" data-width="1314" data-height="916" src="https://cdn-images-1.medium.com/max/800/0*zkpDhGx22Tq8MDYH.png"></figure><blockquote name="bed2" id="bed2" class="graf graf--blockquote graf-after--figure">Презентований 27 лютого 2024 року GitHub Copilot Enterprise має знання на базі всіх репозиторіїв компанії, і якщо інші конкуренти зможуть, то вони також підтягнуться.</blockquote><p name="6732" id="6732" class="graf graf--p graf-after--blockquote graf--trailing">В <strong class="markup--strong markup--p-strong">Codeium </strong>також є функція <em class="markup--em markup--p-em">пошуку </em>по коду репозиторія, але у мене вона погано працювала. <strong class="markup--strong markup--p-strong">Cody</strong> побудований компанією, яка займається <em class="markup--em markup--p-em">пошуком </em>та автопатчингом коду <a href="https://sourcegraph.com/code-search" data-href="https://sourcegraph.com/code-search" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Sourcegraph</a>, але поки що як я розумію ці дві системи не дуже інтегровані.</p></div></div></section><section name="f360" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0ce1" id="0ce1" class="graf graf--p graf--leading">Наразі актуальна задача для ШІ систем полягає в тому, щоб новий код генерувався не просто загально, а в контексті вже існуючого проекту, розуміючи його логіку та стилістику.</p><p name="bfdd" id="bfdd" class="graf graf--p graf-after--p graf--trailing">Я пошукав та затестив ряд незалежних стартап у форматі “чат з вашим репозиторієм”, і всі вони працюють так погано та виглядають так сиро, що навіть згадувати про них немає сенсу.</p></div></div></section><section name="34be" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6957" id="6957" class="graf graf--h3 graf--leading">(4) Мрії про автономних агентів</h3><p name="7508" id="7508" class="graf graf--p graf-after--h3">На даний момент немає жодного продакшн-реді проекту. Проте вигляд та можливість таких систем стали відомі завдяки хайпу навколо <strong class="markup--strong markup--p-strong">Devin </strong>(<a href="https://www.cognition-labs.com/introducing-devin" data-href="https://www.cognition-labs.com/introducing-devin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">сайт</a>)— коли хитрі маркетологи “продали” ШІ розробника інвесторам маючи лише <em class="markup--em markup--p-em">змонтоване </em>відеодемо не з реального часу.</p><figure name="49d0" id="49d0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*hLd7SIatbmXaPPA6.png" data-width="1042" data-height="601" src="https://cdn-images-1.medium.com/max/800/0*hLd7SIatbmXaPPA6.png"><figcaption class="imageCaption">На відео Devin має чат, окреми планер, shell термінал, браузер.</figcaption></figure><p name="c140" id="c140" class="graf graf--p graf-after--figure">Розбір сумнівності цього є у <a href="https://www.youtube.com/watch?v=tNmgmwEtoWE&amp;pp=ygUFRGV2aW4%3D" data-href="https://www.youtube.com/watch?v=tNmgmwEtoWE&amp;pp=ygUFRGV2aW4%3D" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">відео</a> від “Internet of Bugs”.</p><p name="4b26" id="4b26" class="graf graf--p graf-after--p">Відразу почали з’являтися відкриті <strong class="markup--strong markup--p-strong">клони </strong>і всі вони досить сирі: <a href="https://github.com/OpenDevin/OpenDevin" data-href="https://github.com/OpenDevin/OpenDevin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">OpenDevin</a>, <a href="https://github.com/stitionai/devika" data-href="https://github.com/stitionai/devika" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Devika</a>, <a href="https://github.com/MohammedAly22/Kevin" data-href="https://github.com/MohammedAly22/Kevin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Kevin</a>, спеціалізований <a href="https://github.com/princeton-nlp/SWE-agent" data-href="https://github.com/princeton-nlp/SWE-agent" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SWE-agent</a>.</p><blockquote name="74c9" id="74c9" class="graf graf--blockquote graf-after--p">Мрії про агентів, які будуть працювати замість нас, з’явилися майже одразу після появи перших чатів на GPT-3.5-turbo, але вони не могли надати жодного зрозумілого результату. Після того з’явився GPT-4, і такі системи стали розв’язувати прості завдання, але вартість одного запуску становила приблизно 10–15 доларів за використання токенів по API. Пізніше з’явилася більш дешева версія GPT-4-turbo, та також люди навчилися краще оптимізувати використання токенів, тепер простий код вони можуть написати за 4–5 доларів.</blockquote><p name="cdd0" id="cdd0" class="graf graf--p graf-after--blockquote">У загальному, те, чого ми хочемо досягти, ми можемо побачити на цій діаграмі з презентації проекту <a href="https://github.com/geekan/MetaGPT" data-href="https://github.com/geekan/MetaGPT" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">metaGPT</a>. Нам потрібно створити декілька кастомних LLM-агентів і розподілити між ними завдання — загального планування та архітектури системи, створення інтерфейсу, написання коду та його перевірку.</p><figure name="3669" id="3669" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*hih2dcHj4oanS85f.png" data-width="1102" data-height="579" src="https://cdn-images-1.medium.com/max/800/0*hih2dcHj4oanS85f.png"></figure><p name="52c7" id="52c7" class="graf graf--p graf-after--figure">Якщо це працюватиме повністю автоматично, LLM повинні не допускати помилок <em class="markup--em markup--p-em">взагалі</em>, або нам потрібні додаткові агенти, які будуть <strong class="markup--strong markup--p-strong">перевіряти роботу</strong> цих агентів.<em class="markup--em markup--p-em"> І хто буде перевіряти тих агентів, які перевіряють?</em></p><p name="a6f7" id="a6f7" class="graf graf--p graf-after--p">Отже, нам все одно бажано мати присутність людини і такі проекти є більш життєздатними. Наприклад, це <a href="https://github.com/joaomdmoura/crewAI" data-href="https://github.com/joaomdmoura/crewAI" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">crewAI</a> чи <a href="https://github.com/Pythagora-io/gpt-pilot" data-href="https://github.com/Pythagora-io/gpt-pilot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GPT Pilot</a>.</p><blockquote name="6e33" id="6e33" class="graf graf--blockquote graf-after--p graf--trailing">Також нам потрібна дійсно швидка та більше дешева генерація токенів, як то вміє робити <a href="https://groq.com/" data-href="https://groq.com/" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">Groq LPU</a>. Але вони поки що не розгорнули у себе тюнінгованих на коді моделей, тому тільки Llama3–70b більш менш працює ок з кодом.</blockquote></div></div></section><section name="a9af" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="3ff7" id="3ff7" class="graf graf--h4 graf--leading">Перевірка якості коду</h4><p name="7eec" id="7eec" class="graf graf--p graf-after--h4">Спрощена задача полягає в перевірці коду одним агентом, який був згенерований іншим — <strong class="markup--strong markup--p-strong">перевірити імпорти</strong> та версії бібліотек, надалі <strong class="markup--strong markup--p-strong">запустити код</strong> і, якщо є помилки в консолі, відправити їх моделі, щоб вона внесла правки, і так продовжувати, допоки код не працюватиме. Хоча, звісно, це не гарантує правильність його логіки.</p><blockquote name="3d06" id="3d06" class="graf graf--blockquote graf-after--p">Зараз таке можна робити на <a href="https://github.com/langchain-ai/langgraph" data-href="https://github.com/langchain-ai/langgraph" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">LangGraph</a> — <a href="https://youtu.be/MvNdgmM7uyc" data-href="https://youtu.be/MvNdgmM7uyc" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">відео</a>.</blockquote><p name="dcdb" id="dcdb" class="graf graf--p graf-after--blockquote graf--trailing">Поки що я не бачу майбутнього у великих роях агентів, які генерують <strong class="markup--strong markup--p-strong">проекти з нуля</strong>, але для Enterprise думаю створять рої, які самі ходитимуть по всім репозиторіям, шукатимуть помилки, читатимуть тікети з багтрекерів, розгортатимуть проекти, перевірятимуть, що не працює, автоматично створюватимуть патчі та відправлятимуть людям пул-реквести на підтвердження. Ймовірно GitHub Copilot щось таке зробить.</p></div></div></section><section name="b55e" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><blockquote name="226e" id="226e" class="graf graf--pullquote graf--leading graf--trailing">Ця стаття написана для пабліка <a href="https://t.me/llms4coding" data-href="https://t.me/llms4coding" class="markup--anchor markup--pullquote-anchor" rel="nofollow noopener" target="_blank">https://t.me/llms4coding</a>, де я публікую новини з теми роботи LLM з кодом.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@danvoronov" class="p-author h-card">Dan Voronov</a> on <a href="https://medium.com/p/e93fdbb1997c"><time class="dt-published" datetime="2024-04-19T11:17:13.841Z">April 19, 2024</time></a>.</p><p><a href="https://medium.com/@danvoronov/%D1%88%D1%96-%D0%B2-%D1%80%D0%BE%D0%B7%D1%80%D0%BE%D0%B1%D1%86%D1%96-%D0%BF%D0%B7-%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%B9-%D1%81%D1%82%D0%B0%D0%BD-%D1%82%D0%B0-%D0%BF%D0%B5%D1%80%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%B8-e93fdbb1997c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 15, 2025.</p></footer></article></body></html>